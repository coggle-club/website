<!-- Coggle 30 Days of ML（23年7月） -->
<!-- 30天入门数据竞赛 -->
<!-- 2023-06-01 -->
<!-- <a target="_blank" href="https://www.zhihu.com/people/ashui233/">阿水</a>, <a target="_blank" href="https://www.zhihu.com/people/wang-he-13-93">鱼遇雨欲语与余</a>-->
<!-- <a href="https://coggle.club/blog/30days-of-ml-202307">学习资料</a>##<a href="https://shimo.im/forms/7GVxPfAGLeolSWmr/fill">打卡链接</a>-->

## Part1 内容介绍

近年来，人工智能在自然语言处理领域取得了巨大的进展，其中一项引人注目的技术是生成模型，如OpenAI的GPT-3.5。这类模型通过学习大量的文本数据，具备了生成高质量文本的能力，引发了一系列关于文本生成真实性的讨论。

本月学习内容包括：

- TFIDF文本分类器
- LSTM分类分类器
- BERT文本分类器



## Part2 活动安排


* 免费学习活动，不会收取任何费用。
* **请各位同学添加下面微信，并回复【竞赛学习】，即可参与。**

![](https://cdn.coggle.club/coggle666_qrcode.png)


## Part3 积分说明和奖励

为了激励各位同学完成的学习任务，将学习任务根据难度进行划分，并根据是否完成进行评分难度高中低的任务分别分数为3、2和1。在完成学习后（本次活动，截止8月8），将按照积分顺序进行评选 Top3 的学习者。

打卡地址：[https://shimo.im/forms/BGH249688Ac8EdIf/fill](https://shimo.im/forms/BGH249688Ac8EdIf/fill)

| 昵称          | T1   | T2   | T3   | T4   | T5   | T6   | T7   | T8   | T9   | T10  | T11  |
| :------------ | :--- | :--- | :--- | :--- | :--- | :--- | ---- | ---- | ---- | ---- | ---- |
| 徐乜乜        | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    | ✅     | ✅     |✅      | ✅     |
| mryxj         | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    | ✅     |   ✅   |   ✅   |  ✅    |
| 皮卡丘pikachu | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    | ✅     |   ✅   |   ✅   |     |
| liuqingmin    | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    |      |      |      |      |
| 芒果留了果    | ✅    | ✅    | ✅    | ✅    | ✅    |      |      |      |      |      |      |
| 苏照          | ✅    | ✅    |      |      |      |      |      |      |      |      |      |
| 真真夜夜      | ✅    | ✅    |      |      |      |      |      |      |      |      |      |
| 灵泽          | ✅    |      |      |      |      |      |      |      |      |      |      |
| awyys9528     | ✅    |      |      |      |      |      |      |      |      |      |      |
| hygge         | ✅    |      |      |      |      |      |      |      |      |      |      |
| Payen         | ✅    |      |      |      |      |      |      |      |      |      |      |

### 讯飞比赛奖励

> 前十名将获得由 “讯飞 x Datawhale” 联合颁发的优秀选手证书。

赛题在讯飞比赛平台上举办，可以在平台上提交结果并获取奖励。赛题设立一、二、三等奖及优秀奖共十名，具体详情如下：

- 一等奖：1支队伍，周赛一等奖证书，奖金：1000元；
- 二等奖：1支队伍，周赛二等奖证书，奖金：800元；
- 三等奖：1支队伍，周赛三等奖证书，奖金：500元；
- 优秀奖：10支队伍。



### 打卡积分奖励

此外在讯飞比赛的基础上，参赛选手可以参与打卡并获取如下奖励：

Top1的学习者将获得以下奖励：

- 蓝牙黑胶音箱
- Coggle 竞赛专访机会

Top2-3的学习者将获得以下奖励：
- 20元红包
- Coggle 竞赛专访机会



历史活动打卡链接，可以参考如下格式：
- [https://blog.csdn.net/weixin_42551154/article/details/125474519](https://blog.csdn.net/weixin_42551154/article/details/125474519)
- [https://blog.csdn.net/weixin_42551154/article/details/125481695](https://blog.csdn.net/weixin_42551154/article/details/125481695)


## Part4 ChatGPT检测器

### 背景介绍

近年来人工智能在自然语言处理领域取得了巨大的进展。其中一项引人注目的技术是生成模型，如OpenAI的GPT-3.5。这类模型通过学习大量的文本数据，具备了生成高质量文本的能力，从而引发了一系列关于文本生成真实性的讨论。

正因为生成模型的迅猛发展，也引发了一个新的挑战，即如何区分人类编写的文本与机器生成的文本。传统上，我们借助语法错误、逻辑不连贯等特征来辨别机器生成的文本，但随着生成模型的不断改进，这些特征变得越来越难以区分。因此，为了解决这一问题，研究人员开始探索使用NLP文本分类技术来区分人类编写的文本和机器生成的文本。

### 打卡任务
| 任务名称                                        | 所需技能             |
| ----------------------------------------------- | -------------------- |
| 报名比赛，下载比赛数据集并完成读取              | Pandas               |
| 对数据集字符进行可视化，统计标签和字符分布      | Pandas               |
| 使用 TFIDF 提取文本特征                         | Sklearn              |
| 使用 TFIDF 特征 和 线性模型完成训练和预测       | Sklearn              |
| 使用 TFIDF 特征 和 XGBoost 完成训练和预测       | Sklearn、XGBoost     |
| 学会训练 FastText、Word2Vec 词向量              | FastText、gensim     |
| 使用 Word2Vec 词向量，搭建 TextCNN 模型训练预测 | Pytorch、Keras       |
| 使用 Word2Vec 词向量，搭建 BILSTM 模型训练预测  | Pytorch、Keras       |
| 学会 Bert 基础，transformer 库基础使用          | Pytorch、transformer |
| 使用 Bert 在比赛数据集中完成预训练              | Pytorch、transformer |
| 使用 Bert 在比赛数据集上完成微调                | Pytorch、transformer |


#### 任务一：报名比赛，下载比赛数据集并完成读取
- 说明：在这个任务中，你需要访问比赛地址并完成比赛报名。然后，下载比赛数据集，并使用Pandas库完成数据集的读取和加载。
- 实践步骤：
  1. 访问比赛地址：[https://challenge.xfyun.cn/topic/info?type=text-detector&ch=vWxQGFU](https://challenge.xfyun.cn/topic/info?type=text-detector&ch=vWxQGFU)
  2. 完成比赛报名并获取数据集下载链接。
  3. 使用下载链接下载比赛数据集。
  4. 使用Pandas库读取和加载数据集，将数据转化为可供处理的数据结构。

```python
import pandas as pd
train_data = pd.read_csv('./ChatGPT生成文本检测器公开数据-更新/train.csv')
test_data = pd.read_csv('./ChatGPT生成文本检测器公开数据-更新/test.csv')
```

数据集可能以压缩文件的形式提供，因此你可能需要解压缩文件。上述代码假设数据集文件夹的路径为'./ChatGPT生成文本检测器公开数据-更新/'，并且数据集文件名分别为'train.csv'和'test.csv'。根据实际情况，你可能需要调整文件路径和文件名。通过完成以上步骤，你将能够获取比赛数据集并加载到Pandas数据结构中，从而为后续的文本分类任务做好准备。

根据提供的数据集示例，数据集包含三列：name、label和content。下面是对每一列的解释：
- name：数据的索引或编号。
- label：文本的标签，表示文本原始是否来自ChatGPT/ChatGLM。0表示人类编写的文本，1表示机器生成的文本。
- content：文本经过匿名编码后的结果，按照字符进行编码。

| name | label | content                                                      |
| ---: | ----: | :----------------------------------------------------------- |
|    1 |     0 | [4509 3181 1253 2278  290 3562 2051  599 3125 4790 1504 5219 4390 4544 ... |
|    2 |     1 | [ 263 1325 2563 4160 2196  169 3125 2563 2619 2091 4799 3609 3230 5212 ... |

#### 任务二：对数据集字符进行可视化，统计标签和字符分布
- 说明：在这个任务中，你需要使用Pandas库对数据集的字符进行可视化，并统计数据集中的标签和字符的分布情况，以便更好地理解数据集。
- 实践步骤：
  1. 使用Pandas库读取和加载数据集。
  2. 使用Pandas的可视化功能，如柱状图或饼图，对数据集的字符进行可视化展示。
  3. 使用Pandas的统计功能，如value_counts()方法，统计数据集中的标签和字符的分布情况。

```python
# 对输入的内容进行处理
train_data['content'] = train_data['content'].apply(lambda x: x[1:-1].strip().replace('\n', ' \n '))
test_data['content'] = test_data['content'].apply(lambda x: x[1:-1].strip().replace('\n', ' \n '))

train_data['content'] = train_data['content'].apply(lambda x: x.split(' '))
test_data['content'] = test_data['content'].apply(lambda x: x.split(' '))

# 统计字符出现的频次并输出前10个最常见的字符
from collections import Counter
c = Counter()
for content in train_data['content']:
    c.update(content)
c.most_common(10)
```

#### 任务三：使用TFIDF提取文本特征
- 说明：在这个任务中，你需要使用Sklearn库中的TFIDF技术来提取文本特征，将文本转化为可供机器学习算法使用的数值表示。
- 实践步骤：
  1. 准备文本数据集。
  2. 使用Sklearn的[`TfidfVectorizer`](https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html)类，设置相应的参数（如`ngram_range`、`max_features`等）来构建TFIDF特征提取器。
  3. 使用[`TfidfVectorizer`](https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html)的`fit_transform()`方法，对文本数据集进行特征提取，得到TFIDF特征矩阵。

[`TfidfVectorizer`](https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html)是scikit-learn库中的一个文本特征提取工具，用于将文本数据转换为TF-IDF特征表示。下面是对`TfidfVectorizer`函数的功能和常用超参数的介绍：

-   `ngram_range`：特征中要包含的n元语法范围，默认为(1, 1)，表示只提取单个词。
-   `max_df`：单词的最大文档频率，超过该频率的单词将被忽略，默认为1.0，表示不忽略任何单词。
-   `min_df`：单词的最小文档频率，低于该频率的单词将被忽略，默认为1，表示不忽略任何单词。

```python
from sklearn.feature_extraction.text import TfidfVectorizer

tfidf = TfidfVectorizer()
tfidf.fit(train_data['content'].apply(lambda x: ' '.join(x)))
train_tfidf_feat = tfidf.transform(train_data['content'].apply(lambda x: ' '.join(x)))
test_tfidf_feat = tfidf.transform(train_data['content'].apply(lambda x: ' '.join(x)))

tfidf = TfidfVectorizer(ngram_range=(1,2), max_features=5000)
tfidf.fit(train_data['content'].apply(lambda x: ' '.join(x)))
train_tfidf_feat = tfidf.transform(train_data['content'].apply(lambda x: ' '.join(x)))
test_tfidf_feat = tfidf.transform(test_data['content'].apply(lambda x: ' '.join(x)))
```

#### 任务四：使用TFIDF特征和线性模型完成训练和预测
- 说明：在这个任务中，你需要使用TFIDF特征和线性模型（如逻辑回归）完成训练和预测，通过机器学习算法来区分人类编写的文本和机器生成的文本。
- 实践步骤：
  1. 准备TFIDF特征矩阵和相应的标签。
  2. 划分训练集和验证集集。
  3. 使用Sklearn中的线性模型（如逻辑回归）进行训练，并使用训练好的模型对验证集集进行预测。
  4. 评估模型的性能，如准确率、精确率、召回率等指标。
  5. 选择得到合适的模型，对测试集进行预测，并提高到比赛页面[https://challenge.xfyun.cn/topic/info?type=text-detector&ch=vWxQGFU](https://challenge.xfyun.cn/topic/info?type=text-detector&ch=vWxQGFU)

```python
from sklearn.model_selection import cross_val_predict
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report

tfidf = TfidfVectorizer()
tfidf.fit(train_data['content'].apply(lambda x: ' '.join(x)))
train_tfidf_feat = tfidf.transform(train_data['content'].apply(lambda x: ' '.join(x)))
test_tfidf_feat = tfidf.transform(test_data['content'].apply(lambda x: ' '.join(x)))

# 使用cross_val_predict()函数进行交叉验证
val_pred = cross_val_predict(
    LogisticRegression(),
    train_tfidf_feat,
    train_data['label']
)
# 计算并输出分类报告
print(classification_report(train_data['label'], val_pred, digits=3))
```

```
              precision    recall  f1-score   support

           0      0.981     0.999     0.990     11836
           1      0.992     0.892     0.940      2164

    accuracy                          0.982     14000
   macro avg      0.986     0.946     0.965     14000
weighted avg      0.982     0.982     0.982     14000
```

在这个场景中使用交叉验证的目的是为了更准确地评估模型的性能和泛化能力。交叉验证是一种评估机器学习模型的统计方法，通过将数据集划分为多个子集，在不同的训练和验证集上多次训练和评估模型，以得到更可靠的性能指标。

如果你想要提高模型的精度，可以尝试调整`TfidfVectorizer`的一些超参数。以下是一些常用的超参数，你可以根据实际情况进行调整：

1.  `ngram_range`：n元语法范围。通过将`ngram_range`设置为大于1的值，可以考虑多个连续的词作为特征，从而捕捉更多的语义信息。例如，将`ngram_range`设置为(1, 2)可以同时考虑单个词和相邻的词作为特征。
2.  `max_df`和`min_df`：单词的最大和最小文档频率。通过调整`max_df`和`min_df`的值，可以过滤掉在太多或太少文档中出现的单词，从而减少噪声和特异性单词的影响。
3.  `max_features`：最大特征数。通过限制特征的数量，可以减少特征空间的维度，从而减少模型的复杂性和计算量。
4.  `stop_words`：停用词列表。通过设置适当的停用词列表，可以去除常见的、对分类任务没有帮助的词语，从而减少噪声。
5.  `sublinear_tf`：子线性TF缩放。通过将`sublinear_tf`设置为True，可以使用子线性缩放来平衡长文本和短文本的特征权重，从而提高模型对不同长度文本的适应性。
6.  `norm`：特征向量的归一化方式。通过调整`norm`参数，可以选择不同的归一化方式，如'l2'、'l1'或'none'，以适应不同的数据分布。

```python
# 生成测试集结果
m = LogisticRegression()
m.fit(train_tfidf_feat, train_data['label'])
test_pred = m.predict(test_tfidf_feat)
test_data['label'] = test_pred
test_data[['name', 'label']].to_csv('lr.csv', index=None)
```

#### 任务五：使用TFIDF特征和XGBoost完成训练和预测
- 说明：在这个任务中，你需要使用TFIDF特征和XGBoost算法完成训练和预测，进一步提升文本分类的性能。
- 实践步骤：
  1. 准备TFIDF特征矩阵和相应的标签。
  2. 划分训练集和测试集。
  3. 使用Sklearn中的XGBoost算法进行训练，并使用训练好的模型对测试集进行预测。
  4. 评估模型的性能，如准确率、精确率、召回率等指标。
  5. 选择得到合适的模型，对测试集进行预测，并提高到比赛页面[https://challenge.xfyun.cn/topic/info?type=text-detector&ch=vWxQGFU](https://challenge.xfyun.cn/topic/info?type=text-detector&ch=vWxQGFU)

```python
from sklearn.model_selection import cross_val_predict
from xgboost import XGBClassifier
from sklearn.metrics import classification_report

tfidf = TfidfVectorizer(ngram_range=(1,3), max_features=10000)
tfidf.fit(train_data['content'].apply(lambda x: ' '.join(x)))
train_tfidf_feat = tfidf.transform(train_data['content'].apply(lambda x: ' '.join(x)))
test_tfidf_feat = tfidf.transform(test_data['content'].apply(lambda x: ' '.join(x)))

val_pred = cross_val_predict(
    XGBClassifier(n_estimators=50),
    train_tfidf_feat,
    train_data['label']
)
print(classification_report(train_data['label'], val_pred, digits=3))
```

```python
m = XGBClassifier(n_estimators=50)
m.fit(train_tfidf_feat, train_data['label'])
test_pred = m.predict(test_tfidf_feat)
test_data['label'] = test_pred
test_data[['name', 'label']].to_csv('xgb.csv', index=None)
```

#### 任务六：学会训练Word2Vec词向量
- 说明：在这个任务中，你将学习如何训练FastText和Word2Vec词向量模型，这些词向量模型可以捕捉文本中的语义信息。
- 实践步骤：
  1. 准备大规模文本语料库。
  2. 使用Word2Vec类，设置相应的参数（如词向量维度、窗口大小、训练迭代次数等）来构建词向量模型。
  4. 使用Word2Vec类，训练词向量模型。

```
from gensim.models import Word2Vec
model = Word2Vec(sentences=[['1', '2', '3'], ['2', '3', '4']], vector_size=100, window=5, min_count=1, workers=4)
model.wv.most_similar('1', topn=10)

model = Word2Vec(sentences=list(train_data['content']), vector_size=100, window=5, min_count=1, workers=4)
```

#### 任务七：使用Word2Vec词向量，搭建TextCNN模型进行训练和预测
- 说明：在这个任务中，你将使用Word2Vec词向量，搭建TextCNN模型进行文本分类的训练和预测，通过卷积神经网络来进行文本分类。
- 实践步骤：
  1. 准备Word2Vec词向量模型和相应的训练数据集。
  2. 构建TextCNN模型，包括卷积层、池化层、全连接层等。
  3. 将Word2Vec词向量应用到模型中，作为词特征的输入。
  4. 使用训练数据集对TextCNN模型进行训练。
  5. 使用训练好的TextCNN模型对测试数据集进行预测。

#### 任务八：使用Word2Vec词向量，搭建BILSTM模型进行训练和预测
- 说明：在这个任务中，你将使用Word2Vec词向量，搭建BILSTM模型进行文本分类的训练和预测，通过双向长短期记忆网络来进行文本分类。
- 实践步骤：
  1. 准备Word2Vec词向量模型和相应的训练数据集。
  2. 构建BILSTM模型，包括嵌入层、BILSTM层、全连接层等。
  3. 将Word2Vec词向量应用到模型中，作为词特征的输入。
  4. 使用训练数据集对BILSTM模型进行训练。
  5. 使用训练好的BILSTM模型对测试数据集进行预测。

#### 任务九：学会Bert基础，transformer库基础使用
- 说明：在这个任务中，你将学习Bert模型的基础知识，并了解transformer库的基本使用方法，transformer库提供了Bert模型的实现。
- 实践步骤：
  1. 学习Bert模型的原理和架构。
  2. 了解transformer库的基本使用方法，包括Bert模型的初始化、输入编码和特征提取等操作。

#### 任务十：使用Bert在比赛数据集中完成预训练
- 说明：在这个任务中，你将使用Bert模型在比赛数据集上完成预训练，通过预训练的Bert模型来提取文本特征。
- 实践步骤：
  1. 准备比赛数据集和相应的预训练参数。
  2. 使用transformer库中的Bert模型，加载预训练参数。
  3. 使用Bert模型对比赛数据集进行预训练，提取文本特征。

#### 任务十一：使用Bert在比赛数据集上完成微调
- 说明：在这个任务中，你将使用Bert模型在比赛数据集上进行微调，进一步提升文本分类的性能。
- 实践步骤：
  1. 准备比赛数据集和相应的微调参数。
  2. 使用transformer库中的Bert模型，加载微调参数。
  3. 使用微调后的Bert模型对比赛数据集进行微调，提高文本分类的性能。

通过完成这些任务，你将学习到丰富的文本分类技术和模型训练方法，掌握了使用Pandas、Sklearn、FastText、Word2Vec、Pytorch等工具和库进行文本处理和训练的技能。祝你在学习和实践中取得好成绩！

### 基础TFIDF思路

```python
import glob
import numpy as np
import pandas as pd
from sklearn.linear_model import LogisticRegression
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import cross_val_predict

train_data = pd.read_csv('./ChatGPT生成文本检测器公开数据-更新/train.csv')
test_data = pd.read_csv('./ChatGPT生成文本检测器公开数据-更新/test.csv')
train_data['content'] = train_data['content'].apply(lambda x: x[1:-1])
test_data['content'] = test_data['content'].apply(lambda x: x[1:-1])

tfidf = TfidfVectorizer(token_pattern=r'\w{1}', max_features=2000)
train_tfidf = tfidf.fit_transform(train_data['content'])
test_tfidf = tfidf.fit_transform(test_data['content'])
m = LogisticRegression()
m.fit(
    train_tfidf,
    train_data['label']
)
submit = pd.read_csv('sample_submit.csv')
submit = submit.sort_values(by='name')
submit['label'] = m.predict(test_tfidf).astype(int)
submit.to_csv('lr.csv', index=None)
```
